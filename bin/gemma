#!/usr/bin/env ruby
#
# == gemma
#
# Create new gem from template(s).
# Options can be specified on the command line or interactively.
#
# == Usage
#
# gemma new [options]
#
# -h, --help::
#   show this message
#
# --name=name::
#   name of the gem to create; if unspecified, gemma assumes that you want to
#   create the gem interactively, and prompts will be given for any other
#   arguments not specified on the command line.
#
# --dir=name::
#   directory to create the new gem in; default is the name of the gem; specify
#   --dir=. to make the current directory the root of the gem.
#
# --module=name::
#   name of module that contains the gem contents (e.g. MyNewGem for a gem
#   called my_new_gem); by default, this is computed from the gem name.
#
# --template=path::
#   path to template to use instead of default template(s); specify this
#   argument multiple times to copy from several templates (in order). 
#

require 'getoptlong'
require 'rdoc/usage'

require 'rubygems'
require 'gemma'
require 'highline'

#
# Process options.
#
command = ARGV.shift
unless command && command == "new"
  RDoc::usage
end

getopt = GetoptLong.new(
  ['--help',     '-h', GetoptLong::NO_ARGUMENT      ],
  ['--name',           GetoptLong::REQUIRED_ARGUMENT],
  ['--dir',            GetoptLong::REQUIRED_ARGUMENT],
  ['--module',         GetoptLong::REQUIRED_ARGUMENT],
  ['--template',       GetoptLong::REQUIRED_ARGUMENT]
)

opts = {}
opts['--template'] = []
getopt.each do |opt, arg|
  case opt
  when '--help' then
    RDoc::usage
  when '--template' then
    opts['--template'] << arg
  else
    opts[opt] = arg
  end
end

#
# Create from template; prompt for any missing info.
#
hl = HighLine.new
gt = Gemma::GemFromTemplate.new

interactive = !opts['--name'] || opts['--name'].empty?

if interactive
  puts 
  puts "creating a new gem with gemma..."
  puts 

  def ask prompt, default=nil, validate=nil
    answer = default
    case validate
    when Proc then
      validator = validate
    when Regexp then
      validator = proc {|x|
        x =~ validate or begin
          puts "answer must match #{validate}"
          false
        end
      }
    when nil
      validator = proc {|x| true}
    else
      raise ArgumentError.new("validate")
    end

    begin
      print "#{prompt}#{default ? " [#{default}]" : ""}: "
      answer = readline.strip
      answer = default if answer.empty?
    end until answer && validator.call(answer)
    answer
  end

  def choose prompt, options, default_index=nil
    answer = nil
    begin
      for i in 0...options.size
        puts "%3d. %s" % [i + 1, options[i]]
      end
      print "#{prompt}#{default_index ? " [#{default_index + 1}]" : ""}: "
      answer = readline.strip
      if answer.empty?
        answer = default_index
      else
        answer = answer.to_i - 1
      end
    end until answer && 0 <= answer && answer < options.size
    answer
  end
end

#unless interactive
#  gt.gem_name    = opts['--name']
#else
#  gt.gem_name    = ask('gem name', nil, /^.+$/) # weak validation
#end
#
#if opts['--dir']
#  gt.dir_name    = opts['--dir']
#elsif interactive
#  gt.dir_name    = ask('create gem in directory', gt.dir_name)
#end
#
#if opts['--module']
#  gt.module_name = opts['--module']
#elsif interactive
#  gt.module_name = ask('wrap contents in module called', gt.module_name)
#end

templates = opts['--template']
if templates.empty?
  if interactive
    templates << 'base' << 'test_unit'
    case choose("type of gem", ["library", "program"], 1)
    when 0 then
      # no extras
    when 1 then
      templates << 'executable'
    else
      raise "BUG: bad return from choose"
    end
  else
    templates.push(*Gemma::GemFromTemplate::BUILTIN_TEMPLATES)
  end
  templates.map!{|name| File.join(Gemma::GemFromTemplate::TEMPLATE_ROOT,name)}
end
p templates

#puts "creating gem in #{gt.destination_path}"
#gt.create_gem(templates)
#puts "gem created; to get started, see the following TODO tags:"

